/**
 * G-code Generator for 3D Printer Simulator
 * Generates G-code with different infill patterns
 */
class GCodeGenerator {
    constructor() {
        this.layerHeight = 0.2;
        this.nozzleTemp = 200;
        this.bedTemp = 60;
        this.extrusionCounter = 0;
        this.topBottomLayers = 3; // Number of solid layers at top and bottom
    }

    /**
     * Generate a simple cube with specified infill pattern and density
     */
    generateCube(size = 20, height = 20, infillPattern = 'grid', infillDensity = 20, topBottomLayers = 3) {
        this.topBottomLayers = topBottomLayers;
        this.extrusionCounter = 0; // Reset extrusion counter for each new cube
        let gcode = [];

        // Header
        gcode.push('; Generated by 3D Printer Simulator');
        gcode.push(`; Cube: ${size}x${size}x${height}mm`);
        gcode.push(`; Infill: ${infillPattern} at ${infillDensity}%`);
        gcode.push(`; Top/Bottom Solid Layers: ${this.topBottomLayers}`);
        gcode.push('');

        // Setup
        gcode.push('G28 ; Home all axes');
        gcode.push(`M104 S${this.nozzleTemp} ; Set hotend temperature`);
        gcode.push(`M140 S${this.bedTemp} ; Set bed temperature`);
        gcode.push(`G1 Z${this.layerHeight} F5000 ; Move to first layer height`);
        gcode.push('');

        const layers = Math.floor(height / this.layerHeight);
        const center = size / 2;

        for (let layer = 0; layer < layers; layer++) {
            const z = (layer + 1) * this.layerHeight;
            gcode.push(`; Layer ${layer + 1} (Z=${z.toFixed(2)})`);
            gcode.push(`G1 Z${z.toFixed(2)} F5000`);

            // Perimeter (outer and inner walls)
            gcode = gcode.concat(this.generatePerimeter(size, z, center));

            // Determine if this is a bottom, top, or middle layer
            const isBottomLayer = layer < this.topBottomLayers;
            const isTopLayer = layer >= layers - this.topBottomLayers;

            if (isBottomLayer || isTopLayer) {
                // Solid infill for top and bottom layers
                gcode.push(`; Solid layer ${isBottomLayer ? '(bottom)' : '(top)'}`);
                gcode = gcode.concat(this.generateSolidInfill(size, z, center));
            } else {
                // Sparse infill for middle layers
                if (infillDensity > 0) {
                    gcode.push(`; Sparse infill (${infillDensity}%)`);
                    gcode = gcode.concat(this.generateInfill(size, z, center, infillPattern, infillDensity));
                }
            }

            gcode.push('');
        }

        // End
        gcode.push('; Finish');
        gcode.push('G1 Z' + (height + 10) + ' F5000');
        gcode.push('M104 S0 ; Turn off hotend');
        gcode.push('M140 S0 ; Turn off bed');
        gcode.push('G28 X Y ; Home X and Y');
        gcode.push('M84 ; Disable steppers');

        return gcode.join('\n');
    }

    /**
     * Generate perimeter (single outer wall for learning mode)
     */
    generatePerimeter(size, z, center) {
        const gcode = [];
        const offset = size / 2;

        // Single outer perimeter only - infill will fill the interior
        gcode.push(`G0 X${-offset} Y${-offset} F3000`);
        gcode.push(`G1 X${offset} Y${-offset} E${this.extrusionCounter += 5} F1500`);
        gcode.push(`G1 X${offset} Y${offset} E${this.extrusionCounter += 5}`);
        gcode.push(`G1 X${-offset} Y${offset} E${this.extrusionCounter += 5}`);
        gcode.push(`G1 X${-offset} Y${-offset} E${this.extrusionCounter += 5}`);

        return gcode;
    }

    /**
     * Generate solid infill (for top/bottom layers)
     */
    generateSolidInfill(size, z, center) {
        const gcode = [];
        // Fill to just inside the outer perimeter (leave ~0.2mm for wall)
        const offset = size / 2 - 0.2;
        const lineSpacing = 0.15; // Very tight spacing for fully solid appearance

        for (let y = -offset; y <= offset; y += lineSpacing) {
            const lineIndex = Math.floor((y + offset) / lineSpacing);
            if (lineIndex % 2 === 0) {
                gcode.push(`G0 X${-offset.toFixed(2)} Y${y.toFixed(2)} F3000`);
                gcode.push(`G1 X${offset.toFixed(2)} Y${y.toFixed(2)} E${this.extrusionCounter += 3} F1500`);
            } else {
                gcode.push(`G0 X${offset.toFixed(2)} Y${y.toFixed(2)} F3000`);
                gcode.push(`G1 X${-offset.toFixed(2)} Y${y.toFixed(2)} E${this.extrusionCounter += 3} F1500`);
            }
        }

        return gcode;
    }

    /**
     * Generate infill based on pattern and density
     */
    generateInfill(size, z, center, pattern, density) {
        switch (pattern) {
            case 'grid':
                return this.generateGridInfill(size, z, center, density);
            case 'lines':
                return this.generateLinesInfill(size, z, center, density);
            case 'honeycomb':
                return this.generateHoneycombInfill(size, z, center, density);
            case 'concentric':
                return this.generateConcentricInfill(size, z, center, density);
            case 'zigzag':
                return this.generateZigzagInfill(size, z, center, density);
            default:
                return this.generateGridInfill(size, z, center, density);
        }
    }

    /**
     * Grid infill (rectilinear)
     */
    generateGridInfill(size, z, center, density) {
        const gcode = [];
        const offset = size / 2 - 0.2; // Fill to just inside outer wall

        // Calculate spacing based on density
        // Higher density = smaller spacing = more lines
        // 100% density = 0.4mm spacing (solid), 10% = ~4mm spacing
        const maxSpacing = 4.0; // Sparse infill at low density
        const minSpacing = 0.4; // Dense infill at high density
        const spacing = maxSpacing - ((density / 100) * (maxSpacing - minSpacing));

        if (density === 0) return gcode; // No infill

        // Horizontal lines
        for (let y = -offset; y <= offset; y += spacing) {
            const lineIndex = Math.floor((y + offset) / spacing);
            if (lineIndex % 2 === 0) {
                gcode.push(`G0 X${(-offset).toFixed(2)} Y${y.toFixed(2)} F3000`); // Travel to start
                gcode.push(`G1 X${offset.toFixed(2)} Y${y.toFixed(2)} E${this.extrusionCounter += 3} F1500`);
            } else {
                gcode.push(`G0 X${offset.toFixed(2)} Y${y.toFixed(2)} F3000`); // Travel to start
                gcode.push(`G1 X${(-offset).toFixed(2)} Y${y.toFixed(2)} E${this.extrusionCounter += 3} F1500`);
            }
        }

        // Vertical lines (for grid pattern)
        if (density < 100) {
            for (let x = -offset; x <= offset; x += spacing) {
                const lineIndex = Math.floor((x + offset) / spacing);
                if (lineIndex % 2 === 0) {
                    gcode.push(`G0 X${x.toFixed(2)} Y${(-offset).toFixed(2)} F3000`); // Travel to start
                    gcode.push(`G1 X${x.toFixed(2)} Y${offset.toFixed(2)} E${this.extrusionCounter += 3} F1500`);
                } else {
                    gcode.push(`G0 X${x.toFixed(2)} Y${offset.toFixed(2)} F3000`); // Travel to start
                    gcode.push(`G1 X${x.toFixed(2)} Y${(-offset).toFixed(2)} E${this.extrusionCounter += 3} F1500`);
                }
            }
        }

        return gcode;
    }

    /**
     * Lines infill (unidirectional)
     */
    generateLinesInfill(size, z, center, density) {
        const gcode = [];
        const offset = size / 2 - 0.2; // Fill to just inside outer wall

        // Calculate spacing based on density
        const maxSpacing = 4.0;
        const minSpacing = 0.4;
        const spacing = maxSpacing - ((density / 100) * (maxSpacing - minSpacing));

        if (density === 0) return gcode;

        for (let y = -offset; y <= offset; y += spacing) {
            const lineIndex = Math.floor((y + offset) / spacing);
            if (lineIndex % 2 === 0) {
                gcode.push(`G0 X${(-offset).toFixed(2)} Y${y.toFixed(2)} F3000`);
                gcode.push(`G1 X${offset.toFixed(2)} Y${y.toFixed(2)} E${this.extrusionCounter += 3} F1500`);
            } else {
                gcode.push(`G0 X${offset.toFixed(2)} Y${y.toFixed(2)} F3000`);
                gcode.push(`G1 X${(-offset).toFixed(2)} Y${y.toFixed(2)} E${this.extrusionCounter += 3} F1500`);
            }
        }

        return gcode;
    }

    /**
     * Honeycomb infill (hexagonal pattern)
     */
    generateHoneycombInfill(size, z, center, density) {
        const gcode = [];
        const offset = size / 2 - 0.2; // Fill to just inside outer wall

        // Calculate spacing based on density
        const maxSpacing = 5.0;
        const minSpacing = 1.0;
        const spacing = maxSpacing - ((density / 100) * (maxSpacing - minSpacing));

        if (density === 0) return gcode;

        // Simplified honeycomb using diagonal lines
        for (let y = -offset; y <= offset; y += spacing) {
            const endY = Math.min(y + spacing, offset);

            // Diagonal up-right
            gcode.push(`G0 X${(-offset).toFixed(2)} Y${y.toFixed(2)} F3000`);
            gcode.push(`G1 X${offset.toFixed(2)} Y${endY.toFixed(2)} E${this.extrusionCounter += 4} F1500`);

            // Diagonal down-right
            gcode.push(`G0 X${(-offset).toFixed(2)} Y${endY.toFixed(2)} F3000`);
            gcode.push(`G1 X${offset.toFixed(2)} Y${y.toFixed(2)} E${this.extrusionCounter += 4} F1500`);
        }

        return gcode;
    }

    /**
     * Concentric infill (concentric squares)
     */
    generateConcentricInfill(size, z, center, density) {
        const gcode = [];
        const maxOffset = size / 2 - 0.2; // Fill to just inside outer wall

        // Calculate spacing based on density
        const maxSpacing = 3.0;
        const minSpacing = 0.5;
        const spacing = maxSpacing - ((density / 100) * (maxSpacing - minSpacing));

        if (density === 0) return gcode;

        for (let offset = maxOffset; offset > 0; offset -= spacing) {
            gcode.push(`G0 X${(-offset).toFixed(2)} Y${(-offset).toFixed(2)} F3000`); // Travel to start
            gcode.push(`G1 X${offset.toFixed(2)} Y${(-offset).toFixed(2)} E${this.extrusionCounter += 3} F1500`);
            gcode.push(`G1 X${offset.toFixed(2)} Y${offset.toFixed(2)} E${this.extrusionCounter += 3}`);
            gcode.push(`G1 X${(-offset).toFixed(2)} Y${offset.toFixed(2)} E${this.extrusionCounter += 3}`);
            gcode.push(`G1 X${(-offset).toFixed(2)} Y${(-offset).toFixed(2)} E${this.extrusionCounter += 3}`);
        }

        return gcode;
    }

    /**
     * Zigzag infill (diagonal lines)
     */
    generateZigzagInfill(size, z, center, density) {
        const gcode = [];
        const offset = size / 2 - 0.2; // Fill to just inside outer wall

        // Calculate spacing based on density
        const maxSpacing = 4.0;
        const minSpacing = 1.0;
        const spacing = maxSpacing - ((density / 100) * (maxSpacing - minSpacing));

        if (density === 0) return gcode;

        let lineIndex = 0;
        for (let x = -offset; x <= offset; x += spacing) {
            const endX = Math.min(x + spacing, offset);

            if (lineIndex % 2 === 0) {
                gcode.push(`G0 X${x.toFixed(2)} Y${(-offset).toFixed(2)} F3000`);
                gcode.push(`G1 X${endX.toFixed(2)} Y${offset.toFixed(2)} E${this.extrusionCounter += 4} F1500`);
            } else {
                gcode.push(`G0 X${x.toFixed(2)} Y${offset.toFixed(2)} F3000`);
                gcode.push(`G1 X${endX.toFixed(2)} Y${(-offset).toFixed(2)} E${this.extrusionCounter += 4} F1500`);
            }
            lineIndex++;
        }

        return gcode;
    }

    // ============================================================
    // CYLINDER GENERATOR
    // ============================================================

    /**
     * Generate a cylinder with specified infill pattern and density
     * @param {number} diameter - Cylinder diameter in mm
     * @param {number} height - Cylinder height in mm
     * @param {string} infillPattern - Infill pattern type
     * @param {number} infillDensity - Infill density (0-100)
     * @param {number} topBottomLayers - Number of solid top/bottom layers
     */
    generateCylinder(diameter = 20, height = 20, infillPattern = 'grid', infillDensity = 20, topBottomLayers = 3) {
        this.topBottomLayers = topBottomLayers;
        this.extrusionCounter = 0;
        let gcode = [];

        // Header
        gcode.push('; Generated by 3D Printer Simulator');
        gcode.push(`; Cylinder: ${diameter}mm diameter x ${height}mm height`);
        gcode.push(`; Infill: ${infillPattern} at ${infillDensity}%`);
        gcode.push(`; Top/Bottom Solid Layers: ${this.topBottomLayers}`);
        gcode.push('');

        // Setup
        gcode.push('G28 ; Home all axes');
        gcode.push(`M104 S${this.nozzleTemp} ; Set hotend temperature`);
        gcode.push(`M140 S${this.bedTemp} ; Set bed temperature`);
        gcode.push(`G1 Z${this.layerHeight} F5000 ; Move to first layer height`);
        gcode.push('');

        const layers = Math.floor(height / this.layerHeight);
        const radius = diameter / 2;

        for (let layer = 0; layer < layers; layer++) {
            const z = (layer + 1) * this.layerHeight;
            gcode.push(`; Layer ${layer + 1} (Z=${z.toFixed(2)})`);
            gcode.push(`G1 Z${z.toFixed(2)} F5000`);

            // Circular perimeter (outer and inner walls)
            gcode = gcode.concat(this.generateCircularPerimeter(radius, z));

            // Determine if this is a bottom, top, or middle layer
            const isBottomLayer = layer < this.topBottomLayers;
            const isTopLayer = layer >= layers - this.topBottomLayers;

            if (isBottomLayer || isTopLayer) {
                // Solid infill for top and bottom layers
                gcode.push(`; Solid layer ${isBottomLayer ? '(bottom)' : '(top)'}`);
                gcode = gcode.concat(this.generateCircularSolidInfill(radius, z));
            } else {
                // Sparse infill for middle layers
                if (infillDensity > 0) {
                    gcode.push(`; Sparse infill (${infillDensity}%)`);
                    gcode = gcode.concat(this.generateCircularInfill(radius, z, infillPattern, infillDensity));
                }
            }

            gcode.push('');
        }

        // End
        gcode.push('; Finish');
        gcode.push('G1 Z' + (height + 10) + ' F5000');
        gcode.push('M104 S0 ; Turn off hotend');
        gcode.push('M140 S0 ; Turn off bed');
        gcode.push('G28 X Y ; Home X and Y');
        gcode.push('M84 ; Disable steppers');

        return gcode.join('\n');
    }

    /**
     * Generate circular perimeter (single outer wall for learning mode)
     */
    generateCircularPerimeter(radius, z) {
        const gcode = [];
        const segments = 48; // Number of segments for circle approximation

        // Single outer perimeter only - infill will fill the interior
        gcode.push(`G0 X${radius.toFixed(2)} Y0 F3000`);
        for (let i = 1; i <= segments; i++) {
            const angle = (i / segments) * 2 * Math.PI;
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);
            gcode.push(`G1 X${x.toFixed(2)} Y${y.toFixed(2)} E${this.extrusionCounter += 0.5} F1500`);
        }

        return gcode;
    }

    /**
     * Generate solid circular infill
     */
    generateCircularSolidInfill(radius, z) {
        const gcode = [];
        // Fill to just inside the outer perimeter
        const innerRadius = radius - 0.2;
        const lineSpacing = 0.15; // Very tight spacing for fully solid appearance

        // Fill with horizontal lines that fit within the circle
        for (let y = -innerRadius; y <= innerRadius; y += lineSpacing) {
            // Calculate x extent at this y using circle equation
            const xExtent = Math.sqrt(innerRadius * innerRadius - y * y);

            if (xExtent > 0.1) {
                const lineIndex = Math.floor((y + innerRadius) / lineSpacing);
                if (lineIndex % 2 === 0) {
                    gcode.push(`G0 X${(-xExtent).toFixed(2)} Y${y.toFixed(2)} F3000`);
                    gcode.push(`G1 X${xExtent.toFixed(2)} Y${y.toFixed(2)} E${this.extrusionCounter += 2} F1500`);
                } else {
                    gcode.push(`G0 X${xExtent.toFixed(2)} Y${y.toFixed(2)} F3000`);
                    gcode.push(`G1 X${(-xExtent).toFixed(2)} Y${y.toFixed(2)} E${this.extrusionCounter += 2} F1500`);
                }
            }
        }

        return gcode;
    }

    /**
     * Generate circular infill patterns
     */
    generateCircularInfill(radius, z, pattern, density) {
        const gcode = [];
        const innerRadius = radius - 0.2; // Fill to just inside outer wall

        // Calculate spacing based on density
        const maxSpacing = 4.0;
        const minSpacing = 0.5;
        const spacing = maxSpacing - ((density / 100) * (maxSpacing - minSpacing));

        if (density === 0) return gcode;

        if (pattern === 'concentric') {
            // Concentric circles
            for (let r = innerRadius; r > 0; r -= spacing) {
                const segments = Math.max(16, Math.floor(r * 2));
                for (let i = 0; i <= segments; i++) {
                    const angle = (i / segments) * 2 * Math.PI;
                    const x = r * Math.cos(angle);
                    const y = r * Math.sin(angle);
                    if (i === 0) {
                        gcode.push(`G0 X${x.toFixed(2)} Y${y.toFixed(2)} F3000`); // Travel to start
                    } else {
                        gcode.push(`G1 X${x.toFixed(2)} Y${y.toFixed(2)} E${this.extrusionCounter += 0.3} F1500`);
                    }
                }
            }
        } else {
            // Grid/lines pattern clipped to circle
            for (let y = -innerRadius; y <= innerRadius; y += spacing) {
                const xExtent = Math.sqrt(Math.max(0, innerRadius * innerRadius - y * y));
                if (xExtent > 0.1) {
                    const lineIndex = Math.floor((y + innerRadius) / spacing);
                    if (lineIndex % 2 === 0) {
                        gcode.push(`G0 X${(-xExtent).toFixed(2)} Y${y.toFixed(2)} F3000`);
                        gcode.push(`G1 X${xExtent.toFixed(2)} Y${y.toFixed(2)} E${this.extrusionCounter += 2} F1500`);
                    } else {
                        gcode.push(`G0 X${xExtent.toFixed(2)} Y${y.toFixed(2)} F3000`);
                        gcode.push(`G1 X${(-xExtent).toFixed(2)} Y${y.toFixed(2)} E${this.extrusionCounter += 2} F1500`);
                    }
                }
            }
        }

        return gcode;
    }

    // ============================================================
    // PYRAMID GENERATOR
    // ============================================================

    /**
     * Generate a pyramid with specified infill pattern and density
     * @param {number} baseSize - Base size of pyramid in mm
     * @param {number} height - Pyramid height in mm
     * @param {string} infillPattern - Infill pattern type
     * @param {number} infillDensity - Infill density (0-100)
     * @param {number} topBottomLayers - Number of solid bottom layers
     */
    generatePyramid(baseSize = 20, height = 20, infillPattern = 'grid', infillDensity = 20, topBottomLayers = 3) {
        this.topBottomLayers = topBottomLayers;
        this.extrusionCounter = 0;
        let gcode = [];

        // Header
        gcode.push('; Generated by 3D Printer Simulator');
        gcode.push(`; Pyramid: ${baseSize}mm base x ${height}mm height`);
        gcode.push(`; Infill: ${infillPattern} at ${infillDensity}%`);
        gcode.push(`; Bottom Solid Layers: ${this.topBottomLayers}`);
        gcode.push('');

        // Setup
        gcode.push('G28 ; Home all axes');
        gcode.push(`M104 S${this.nozzleTemp} ; Set hotend temperature`);
        gcode.push(`M140 S${this.bedTemp} ; Set bed temperature`);
        gcode.push(`G1 Z${this.layerHeight} F5000 ; Move to first layer height`);
        gcode.push('');

        const layers = Math.floor(height / this.layerHeight);

        for (let layer = 0; layer < layers; layer++) {
            const z = (layer + 1) * this.layerHeight;

            // Calculate size at this layer (shrinks linearly from base to tip)
            const progress = layer / layers;
            const currentSize = baseSize * (1 - progress);

            // Stop if layer is too small to print
            if (currentSize < 2) {
                gcode.push(`; Layer ${layer + 1} skipped (too small)`);
                continue;
            }

            gcode.push(`; Layer ${layer + 1} (Z=${z.toFixed(2)}, size=${currentSize.toFixed(1)}mm)`);
            gcode.push(`G1 Z${z.toFixed(2)} F5000`);

            // Square perimeter (shrinking with each layer)
            gcode = gcode.concat(this.generatePyramidPerimeter(currentSize, z));

            // Determine if this is a bottom layer or needs infill
            const isBottomLayer = layer < this.topBottomLayers;

            if (isBottomLayer || currentSize < 5) {
                // Solid infill for bottom layers and small layers near top
                gcode.push(`; Solid layer ${isBottomLayer ? '(bottom)' : '(small)'}`);
                gcode = gcode.concat(this.generatePyramidSolidInfill(currentSize, z));
            } else {
                // Sparse infill for middle layers
                if (infillDensity > 0) {
                    gcode.push(`; Sparse infill (${infillDensity}%)`);
                    gcode = gcode.concat(this.generatePyramidInfill(currentSize, z, infillPattern, infillDensity));
                }
            }

            gcode.push('');
        }

        // End
        gcode.push('; Finish');
        gcode.push('G1 Z' + (height + 10) + ' F5000');
        gcode.push('M104 S0 ; Turn off hotend');
        gcode.push('M140 S0 ; Turn off bed');
        gcode.push('G28 X Y ; Home X and Y');
        gcode.push('M84 ; Disable steppers');

        return gcode.join('\n');
    }

    /**
     * Generate square perimeter for pyramid layer (single outer wall)
     */
    generatePyramidPerimeter(size, z) {
        const gcode = [];
        const offset = size / 2;

        // Single outer perimeter only - infill will fill the interior
        gcode.push(`G0 X${-offset.toFixed(2)} Y${-offset.toFixed(2)} F3000`);
        gcode.push(`G1 X${offset.toFixed(2)} Y${-offset.toFixed(2)} E${this.extrusionCounter += 3} F1500`);
        gcode.push(`G1 X${offset.toFixed(2)} Y${offset.toFixed(2)} E${this.extrusionCounter += 3}`);
        gcode.push(`G1 X${-offset.toFixed(2)} Y${offset.toFixed(2)} E${this.extrusionCounter += 3}`);
        gcode.push(`G1 X${-offset.toFixed(2)} Y${-offset.toFixed(2)} E${this.extrusionCounter += 3}`);

        return gcode;
    }

    /**
     * Generate solid infill for pyramid layer
     */
    generatePyramidSolidInfill(size, z) {
        const gcode = [];
        // Fill to just inside the outer perimeter
        const offset = size / 2 - 0.2;
        const lineSpacing = 0.15; // Very tight spacing for fully solid appearance

        if (offset <= 0) return gcode;

        for (let y = -offset; y <= offset; y += lineSpacing) {
            const lineIndex = Math.floor((y + offset) / lineSpacing);
            if (lineIndex % 2 === 0) {
                gcode.push(`G0 X${-offset.toFixed(2)} Y${y.toFixed(2)} F3000`);
                gcode.push(`G1 X${offset.toFixed(2)} Y${y.toFixed(2)} E${this.extrusionCounter += 2} F1500`);
            } else {
                gcode.push(`G0 X${offset.toFixed(2)} Y${y.toFixed(2)} F3000`);
                gcode.push(`G1 X${-offset.toFixed(2)} Y${y.toFixed(2)} E${this.extrusionCounter += 2} F1500`);
            }
        }

        return gcode;
    }

    /**
     * Generate sparse infill for pyramid layer
     */
    generatePyramidInfill(size, z, pattern, density) {
        const gcode = [];
        // Fill to just inside the outer perimeter
        const offset = size / 2 - 0.2;

        if (offset <= 0) return gcode;

        // Calculate spacing based on density
        const maxSpacing = 4.0;
        const minSpacing = 0.5;
        const spacing = maxSpacing - ((density / 100) * (maxSpacing - minSpacing));

        if (density === 0) return gcode;

        // Lines pattern with proper travel moves
        for (let y = -offset; y <= offset; y += spacing) {
            const lineIndex = Math.floor((y + offset) / spacing);
            if (lineIndex % 2 === 0) {
                gcode.push(`G0 X${(-offset).toFixed(2)} Y${y.toFixed(2)} F3000`);
                gcode.push(`G1 X${offset.toFixed(2)} Y${y.toFixed(2)} E${this.extrusionCounter += 2} F1500`);
            } else {
                gcode.push(`G0 X${offset.toFixed(2)} Y${y.toFixed(2)} F3000`);
                gcode.push(`G1 X${(-offset).toFixed(2)} Y${y.toFixed(2)} E${this.extrusionCounter += 2} F1500`);
            }
        }

        return gcode;
    }
}
